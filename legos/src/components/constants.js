export const defaultEditorsValue = {
    firstDefault: "def greet(name):\n \\\ \n This function greets to\n the person passed in as\n a parameter\n \\\ \n print('Hello, ' + name + '. Good morning!')\n\n\n\n\n\n\n\n\n\n\n\n\n",
    secondDefault: "print(Hello world)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    thirdDefault: "option to do\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
}
export const firstEditorPHIM = `from type_constructor import create_type, create_action, create_pair_action\ntype_dict = dict()\ntime = create_type(\"time\", type_dict, lower_bound=0, upper_bound=100000)\nsid = create_type(\"sid\", type_dict, lower_bound = 0, upper_bound = 100)\naid = create_type(\"aid\", type_dict, lower_bound = 0, upper_bound = 1000)\npid = create_type(\"pid\", type_dict, lower_bound = 0, upper_bound = 5000)\npvalue = create_type(\"pvalue\", type_dict)\npurpose = create_type(\"purpose\", type_dict, lower_bound=0, upper_bound=2)\nexpertise = create_type(\"expertise\", type_dict, lower_bound=0, upper_bound=3)\naction = create_type(\"action\", type_dict, lower_bound=1, upper_bound=2)\nmessage = create_type(\"message\", type_dict, lower_bound=0, upper_bound=10)\nbalance = create_type(\"balance\", type_dict, lower_bound=0)\nTimeStamp = create_action(\"TimeStamp\", [(\"time\", \"time\")],type_dict, abstraction=False)\nBalance = create_action(\"Balance\", [(\"time\", \"time\"), (\"subject\", \"sid\"), (\"balance\", \"balance\")], type_dict, abstraction=False)\nCollect = create_action(\"Collect\", [(\"time\", \"time\"), (\"subject\", \"sid\"),\n                                    (\"pid\", \"pid\"), (\"pvalue\", \"pvalue\"), (\"purpose\",\"purpose\")],type_dict)\nNotify = create_action(\"Notify\", [(\"time\", \"time\"), (\"subject\", \"sid\"),\n                                    (\"message\", \"message\")],type_dict)\nRequest_Update, Update = create_pair_action(\"Update\", [(\"time\", \"time\"), (\"subject\", \"sid\"),\n                                    (\"pid\", \"pid\"), (\"pvalue\", \"pvalue\")],type_dict)\nHas_Expertise = create_action(\"Has_Expertise\",  [(\"time\", \"time\"),\n                                                 (\"expertise\", \"expertise\"), (\"purpose\", \"purpose\")],type_dict)\nRequest_Access = create_action(\"Request_Access\", [(\"time\", \"time\"),\n                                                 (\"pid\", \"pid\"), (\"a1\", \"aid\")],type_dict)\nAccess = create_action(\"Access\", [(\"time\", \"time\"),\n                                                 (\"pid\", \"pid\"), (\"a1\", \"aid\"), (\"pvalue\", \"pvalue\")],type_dict)\nRequest_Use = create_action(\"Request_Use\", [(\"time\", \"time\"),\n                                                 (\"pid\", \"pid\"), (\"a1\", \"aid\")],type_dict)\nUse = create_action(\"Use\", [(\"time\", \"time\"),\n                                                 (\"pid\", \"pid\"), (\"a1\", \"aid\")],type_dict)\nRequest_Disclose = create_action(\"Request_Disclose\", [(\"time\", \"time\"),\n                                                 (\"a1\", \"aid\"), (\"pid\", \"pid\"), (\"pvalue\", \"pvalue\"),\n                                      (\"a2\", \"aid\")],type_dict)\nDisclose = create_action(\"Disclose\", [(\"time\", \"time\"),\n                                                 (\"a1\", \"aid\"), (\"pid\", \"pid\"), (\"pvalue\", \"pvalue\"),\n                                      (\"a2\", \"aid\")],type_dict)\nRequest_Consent =create_action(\"Request_Consent\", [(\"time\", \"time\"),\n                                                 (\"action\", \"action\"), (\"a1\", \"aid\"), (\"pid\", \"pid\"),\n                                      (\"a2\", \"aid\")], type_dict)\nConsent = create_action(\"Consent\", [(\"time\", \"time\"),\n                                                 (\"action\", \"action\"), (\"a1\", \"aid\"), (\"pid\", \"pid\"),\n                                      (\"a2\", \"aid\")], type_dict)\nPatient_Consent = create_action(\"Patient_Consent\", [(\"time\", \"time\"),(\"subject\", \"sid\")], type_dict)\nAuthorize= create_action(\"Authorize\", [(\"time\", \"time\"),\n                                                 (\"permission\", \"action\"), (\"a1\", \"aid\"), (\"pid\", \"pid\")], type_dict)\nRevoke = create_action(\"Revoke\",  [(\"time\", \"time\"),  (\"a1\", \"aid\"), (\"pid\", \"pid\")], type_dict)\nAssign_Expertise = create_action(\"Assign_expertise\",  [(\"time\", \"time\"),  (\"expertise\", \"expertise\"), (\"a1\", \"aid\")], type_dict)\nRequest_Erase, Erase = create_pair_action(\"Erase\", [(\"subject\", \"sid\"), (\"pid\", \"pid\"), (\"time\", \"time\")], type_dict)\nRequest_Patient_Access, Patient_Access = create_pair_action(\"Patient_Access\", [(\"subject\", \"sid\"), (\"pid\", \"pid\"),  (\"pvalue\", \"pvalue\"), (\"time\", \"time\")], type_dict)\nRequest_Action = [Request_Access, Request_Consent, Request_Disclose, Request_Use, Request_Erase, Request_Patient_Access, Request_Update]\nACTION = Request_Action + [Patient_Access, Collect, Update, Has_Expertise, Access, Disclose, Consent, Authorize, Revoke, Assign_Expertise, Patient_Consent, Use, Erase, TimeStamp , Balance]\nACTION_MAP = {}\nfor act in ACTION:\n    ACTION_MAP[act.action_name.upper()] = act\n#additional correction if needed\nACTION_MAP.update( { \"Collect\".upper(): Collect, \"Update\".upper():Update, \"Has_Expertise\".upper(): Has_Expertise, \"Access\".upper(): Access, \"Disclose\".upper(): Disclose,\n               \"Consent\".upper() : Consent, \"Authorize\".upper(): Authorize, \"Revoke\".upper(): Revoke, \"Assign_Expertise\".upper(): Assign_Expertise,\n               \"Patient_consent\".upper(): Patient_Consent, \"USE\":Use})\nstate_action = [Balance, TimeStamp]\n#now creates abstraction\n#create_abstraction(\"pid\", upper_bound=6)\n#create_abstraction(\"sid\", upper_bound=4)\n#create_abstraction(\"pvalue\", upper_bound=4)\n#create_abstraction(\"time\", upper_bound=15, ordered=True)`

export const secondEditorPHIM = `from logic_operator import *\nfrom baby_ddomain import *\nfrom analyzer import check_property_refining, prove_by_induction\nimport time\n​\n########################################################################\n# Shortcuts\n########################################################################\n​\nEQ = Equals\nNEQ = NotEquals\n​\n########################################################################\n# Declarative model\n########################################################################\n​\ndef get_action_name(action_id):\n    if action_id == 1:\n        return \"access\"\n    elif action_id == 2:\n        return \"disclose\"\n​\naction_iteration_bound = 1000\n​\n#pid starts with pid 0\nroot_pid = forall(Collect, lambda collect1 : Implication(GT(collect1.pid, Int(0)),\n                                                             exist(Collect, lambda collect2: AND(EQ(collect2.pid, Int(0)), collect2 < collect1))))\n​\n# patient id unique and increasing\nincrementing_pid = forall(Collect, lambda collect1 : Implication(GT(collect1.pid, Int(0)),\n                                                             OR(exist(Collect, lambda collect2: And(\n                                                                 (EQ(collect1.pid, Plus(collect2.pid, Int(1)))),\n                                                             collect2 < collect1)))))\n​\n#pids are collected in order\nincreasing_pid = forall(Collect, lambda collect1 : forall(Collect, lambda collect2: Implication(collect1 > collect2,\n                                                                                                 GT(collect1.pid, collect2.pid))))\n​\n# A data can be collected only once\nno_double_collect = forall(Collect, lambda c1: forall(Collect, lambda c2: Implication(NOT(c1.build_eq_constraint(c2)),\n                                                                                      NEQ(c1.pid, c2.pid))))\n​\n#update after collection but before deletion\nupdate_after_collection = forall(Request_Update, lambda update: once(Collect, lambda collect: AND(\n                                                                                           EQ(collect.pid, update.pid),\n                                                                                           EQ(collect.subject, update.subject),\n                                                                                                   NOT(exist(Erase, lambda erase: AND(\n                                                                                                             erase <= update,\n                                                                                                             erase >= collect,\n                                                                                                             EQ(erase.pid, collect.pid))\n                                                                                                             ))), update.time))\n​\n#a pid can be accessed only if it has been collected\naccess_after_collection = forall(Access, lambda access: exist(Collect, lambda collect: AND(collect < access,\n                                                                                           EQ(collect.pid, access.pid))))\n​\n#the value of access is the most update to date\naccess_up_to_date_u =  forall(Access, lambda access: forall(Update, lambda update: Implication(AND(update < access,\n                                                                                           EQ(update.pid, access.pid),\n                                                                                      NEQ(update.pvalue, access.pvalue)),\n                                                                                              exist(Update, lambda update1:\n                                                                                                    AND(update1 < access,\n                                                                                                       update1 > update,\n             EQ(update1.pid,\n                                                                                                               access.pid),\n                                                                                                        EQ(update1.pvalue,\n                                                                                                               access.pvalue))))))\n​\naccess_up_to_date_c =  forall(Access, lambda access: forall(Collect, lambda update: Implication(AND(update < access,\n                                                                                           EQ(update.pid, access.pid),\n                                                                                      NEQ(update.pvalue, access.pvalue)),\n                                                                                              exist(Update, lambda update1:\n                                                                                                    AND(update1 < access,\n                                                                                                        update1 > update,\n                                                                                                        EQ(update1.pid,\n                                                                                                               access.pid),\n                                                                                                        EQ(update1.pvalue,\n                                                                                                               access.pvalue))))))\naccess_up_to_date = AND(access_up_to_date_c, access_up_to_date_u)\n​\naccess_not_deleted = forall([Access, Erase], lambda ac, er: Implication(EQ(ac.pid, er.pid),\n                                                                        ac < er))\n​\nrequest_to_update_fullfilled = forall(Request_Update, lambda ur: exist(Update, lambda update:\n                                                                       AND(EQ(ur.pid, update.pid),\n                                                                           EQ(ur.subject, update.subject),\n                                                                           EQ(ur.pvalue, update.pvalue),\n                                                                           LT(update.time, ur.time + Int(30)),\n                                                                           update > ur)))\n​\nno_random_update = forall(Update, lambda update: exist(Request_Update, lambda ur:\n                                                                       AND(EQ(ur.pid, update.pid),\n                                                                           EQ(ur.subject, update.subject),\n                                                                           EQ(ur.pvalue, update.pvalue),\n                                                                           ur < update)))\n​\nno_two_collect_with_time = NOT(exist([Collect, Collect], lambda c1, c2: AND(NEQ(c1.pid, c2.pid), EQ(c1.subject, c2.subject),\n                                                                            c1 > c2,\n                                                                            LT(Minus(c1.time, c2.time), Int(5)))))\n​\n​\nerase_own_data = forall(Erase,lambda erase : exist(Collect, lambda collect: AND(collect < erase, EQ(collect.pid, erase.pid),\n                                                                                 EQ(collect.subject, erase.subject))))\n​\nbalance_of_same_subject = lambda b1, b2: EQ(b1.subject, b2.subject)\nerase_with_balence = forall(Erase, lambda erase : exist(Balance, lambda b1:\n                                                       AND(EQ(b1.subject, erase.subject), GE(b1.balance, Plus(Int(5), b1.time)),\n                                                           EQ(b1.time, erase.time),\n                                                      next(Balance, balance_of_same_subject, lambda b2:\n                                                                AND(EQ(b1.subject, b2.subject),\n                                                                    EQ(b2.balance, Minus(b1.balance, Plus(Int(5), b1.time)))), b1.time))))\n​\n​\n​\n​\n​\nno_conflicting_balance = forall([Balance, Balance], lambda b1, b2: Implication(EQ(b1.subject, b2.subject), Or(NEQ(b1.time, b2.time), b1.build_eq_constraint(b2))))\n​\nvalid_balance = forall(Balance, lambda b1: OR(And(EQ(b1.time, Int(0)), EQ(b1.balance, Int(0))),\n                                              previous(Balance, balance_of_same_subject, lambda b2: AND(EQ(b1.subject, b2.subject),\n                                                                                                        OR(EQ(b1.balance, Int(0)),\n                                                                                                           exist(Collect, lambda collect:\n                                                                                                           AND(\n                                                                                                                 EQ(collect.subject, b2.subject),\n                                                                                                                 EQ(collect.time, b2.time),\n                                                                                                                 EQ(Plus(b2.balance, Int(4)), b1.balance )\n                                                                                                           )\n                                                                                                                 ),\n​\n                                                                                                           exist(Erase, lambda erase:\n                                                                                                           AND(\n                                                                                                                 EQ(erase.subject, b2.subject),\n                                                                                                                 EQ(erase.time, b2.time),\n                                                                                                                 EQ(Minus(b2.balance, Plus(Int(5), b2.time)), b1.balance )\n                                                                                                           )\n                                                                                                                 ),\n​\n                                                                                                        exist(Update, lambda update:\n                                                                                                           AND(\n                                                                                                                 EQ(update.subject, b2.subject),\n                                                                                                                 EQ(update.time, b2.time),\n                                                                                                                 EQ(Plus(b2.balance, Int(3)), b1.balance )\n                                                                                                           )\n                                                                                                                 ),\n​\n​\n​\n                                                                                                           )), b1.time)))\n​\n​\n​\nOne_data_per_person = forall(Collect, lambda c1: forall(Collect, lambda c2:\n                                                        Implication(NEQ(c1.pid, c2.pid),\n                                               NEQ(c1.subject, c2.subject))))\n​\n​\naccess_consented = forall(Access, lambda access: once(Authorize, lambda au:\nAND(EQ(access.pid, au.pid), EQ(access.a1, au.a1), EQ(au.permission, Int(1))),access.time))\n​\n​\naccess_right_purpose = forall(Access, lambda access: once(Collect, lambda collect: AND(EQ(access.pid, collect.pid),\n                                                                                       once(Assign_Expertise,\n                                                                                            lambda ae: AND(EQ(ae.a1, access.a1),\n                                                                                                           exist(Has_Expertise, lambda he:\n                                                                                                                 AND(EQ(he.time, Int(0)),\n                                                                                                                     EQ(he.purpose, collect.purpose),\n                                                                                                                     EQ(ae.expertise, he.expertise)\n                                                                                                                     )\n                                                                                                                 )) ,access.time)), access.time))\n                  \ncomplete_rules = [access_consented, access_right_purpose,  no_two_collect_with_time, increasing_pid, One_data_per_person, incrementing_pid, root_pid, update_after_collection, access_up_to_date,\n             request_to_update_fullfilled, no_random_update, access_after_collection, no_double_collect, erase_own_data, erase_with_balence,\n                  no_conflicting_balance, valid_balance, access_not_deleted]`

export const thirdEditorPHIM = ` # violation against permission to update\ntarget_rule = exist(Request_Update, lambda ru: exist(Collect, lambda collect: \n\t\t\t\t\t\t\t\t\t\t\t\t\texist(TimeStamp, lambda ts: \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  AND(GT(ts.time, ru.time + Int(30)), \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tEQ(collect.subject, ru.subject), \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tEQ(collect.pid, ru.pid), \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcollect < ru, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tNOT(exist(Update, lambda update: \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  AND(EQ(update.pid, ru.pid), \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  EQ(update.subject, ru.subject), \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  EQ(update.pvalue, ru.pvalue), \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  update >= ru, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  update <= ts) \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)) \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t))))`
export const defaultCompletions = [
    { "label": "NOT", "type": "constant", "info": "NOT (arg)" },
    { "label": "AND", "type": "constant", "info": "AND ([args])" },
    { "label": "EQ", "type": "constant", "info": "EQ (left, right)" },
    { "label": "NEQ", "type": "constant", "info": "NEQ (left, right)" },
    { "label": "OR", "type": "constant", "info": "OR ([args])" },
    { "label": "LT", "type": "constant", "info": "LT (left, right)" },
    { "label": "GT", "type": "constant", "info": "GT (left, right)" },
    { "label": "ITE", "type": "constant", "info": "ITE (cond, left, right)" },
    { "label": "IFF", "type": "constant", "info": "IFF (left, right)" },
    { "label": "forall", "type": "constant", "info": "forall (action, function)" },
    { "label": "exist", "type": "constant", "info": "exist (self, input_type, function)" },
    { "label": "Implication", "type": "constant", "info": "Implication (right, left)" },
    { "label": "previous", "type": "constant", "info": "previous (Action_class, idenifier_func, func, current_time = Int(0))" },
    { "label": "next", "type": "constant", "info": "next (Action_class, idenifier_func, func, current_time = Int(0))" },
    { "label": "current", "type": "constant", "info": "current (Action_class, idenifier_func, func, current_time = Int(0))" },
    { "label": "eventually", "type": "constant", "info": "eventually (EAction_class, func, current_time = Int(0))" },
    { "label": "once", "type": "constant", "info": "once (Action_class, func, current_time)" },
    { "label": "until", "type": "constant", "info": "until (EAction, func, Faction, func1, current_time)" },
    { "label": "since", "type": "constant", "info": "since (EAction, func, Faction, func1, current_time)" },
]
